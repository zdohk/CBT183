./ ADD NAME=$$$#DATE 0487-13230-13230-1424-00012-00012-00000-CBT-487
REGULAR CBT TAPE - VERSION 487    FILE:  895

    ORIGINAL DSNAME:  SBGOLOB.CBT487.FILE895
    ---------------
                    --RECFM-LRECL-BLKSIZE-DSORG
                      FB    80    5600    PO

   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,821 RECORDS


TIME THIS PDS WAS SHIPPED:   08/18/13    14:24:35    UTC-4:00

./ ADD NAME=$$NOTE01 0100-13230-13230-1416-00035-00035-00000-SBGOLOB
Subject:  CBT Tape File 183
From:     "Rainer Nowak" <rainer_nowak@gmx.de>
Date:     8/17/2013 4:08 PM
To:       sbgolob@cbttape.org

Hello Mr. Golob,

For many years the CBT tape has been a great help for me. Usually
I used the programs 'as is', but now a colleague wants a way to
show him all the stem variables in a REXX exec.  OK, there's
STEMEDIT in CBT tape file 183, but this can only be used for stem
variables like a.1, a.2 and so on.  One big advantage of REXX is,
that you can use stem variables in the way like a. =0;do i=1 to
words(text);j=WORD(text,i);a.j=a.j+1;end . So you can count how
many times a word is used in a text.  For such stem variables you
can't use STEMEDIT.  So I changed STEMEDIT to VIEW and EDIT all
variables in a REXX exec.  You'll find the changed source in the
zip file I attached to this eMail.

There are also two edit macros to be used with STEMEDIT.  Call
STEMEMCB at the beginning of the edit session to change all '00'x
in blanks and shift the '=' to the left.  At the end of the edit
session STEMEMCE should be called to end up the lines with '00'x.
I've also changed TALLY to work under z/OS 1.13.  I know you don't
need TALLY anymore, because DSLIST now can do this for you.  But
the idea behind TALLY is, to find the ISPF table used by DSLIST
and use it for your own needs.  So I wrote DSL as an example, how
to use this table.  In DSL you can exclude Datasets from the list,
flip between excluded and visible and do HSM RECALL for all
visible Datasets.  I hope these programs will be a help for someone.

Thank you for your help and work for so many years.

Rainer Nowak

./ ADD NAME=@FILE895 0487-13230-13230-1424-00043-00043-00000-CBT-487
//***FILE 895 is from Rainer Nowak and contains some modifications  *   FILE 895
//*           to Gilbert Saint-flour's STEMEDIT program as well as  *   FILE 895
//*           some other things that are related.                   *   FILE 895
//*                                                                 *   FILE 895
//*           Please refer to CBT File 183 for Gilbert              *   FILE 895
//*           Saint-flour's materials.                              *   FILE 895
//*                                                                 *   FILE 895
//*           email:  rainer_nowak@gmx.de                           *   FILE 895
//*                                                                 *   FILE 895
//*                   Description of Contents                       *   FILE 895
//*                   ----------- -- --------                       *   FILE 895
//*                                                                 *   FILE 895
//*     For many years the CBT tape has been a great help for       *   FILE 895
//*     me. Usually I used the programs 'as is', but now a          *   FILE 895
//*     colleague wants a way to show him all the stem variables    *   FILE 895
//*     in a REXX exec.  OK, there's STEMEDIT in CBT tape file      *   FILE 895
//*     183, but this can only be used for stem variables like      *   FILE 895
//*     a.1, a.2 and so on.  One big advantage of REXX is, that     *   FILE 895
//*     you can use stem variables in the way like a. =0;do i=1     *   FILE 895
//*     to words(text);j=WORD(text,i);a.j=a.j+1;end . So you can    *   FILE 895
//*     count how many times a word is used in a text.  For such    *   FILE 895
//*     stem variables you can't use STEMEDIT.  So I changed        *   FILE 895
//*     STEMEDIT to VIEW and EDIT all variables in a REXX exec.     *   FILE 895
//*     You'll find the changed source in the zip file I            *   FILE 895
//*     attached to this eMail.                                     *   FILE 895
//*                                                                 *   FILE 895
//*     There are also two edit macros to be used with              *   FILE 895
//*     STEMEDIT.  Call STEMEMCB at the beginning of the edit       *   FILE 895
//*     session to change all '00'x in blanks and shift the '='     *   FILE 895
//*     to the left.  At the end of the edit session STEMEMCE       *   FILE 895
//*     should be called to end up the lines with '00'x.  I've      *   FILE 895
//*     also changed TALLY to work under z/OS 1.13.  I know you     *   FILE 895
//*     don't need TALLY anymore, because DSLIST now can do         *   FILE 895
//*     this for you.  But the idea behind TALLY is, to find        *   FILE 895
//*     the ISPF table used by DSLIST and use it for your own       *   FILE 895
//*     needs.  So I wrote DSL as an example, how to use this       *   FILE 895
//*     table.  In DSL you can exclude Datasets from the list,      *   FILE 895
//*     flip between excluded and visible and do HSM RECALL for     *   FILE 895
//*     all visible Datasets.  I hope these programs will be a      *   FILE 895
//*     help for someone.                                           *   FILE 895
//*                                                                 *   FILE 895
//*     Rainer Nowak                                                *   FILE 895
//*                                                                 *   FILE 895
./ ADD NAME=DSL      0100-13230-13230-1410-00353-00353-00000-RNOWAK
/* REXX **************************************************************/
/* MEMBER : DSL                                                      */
/*                                                                   */
/* DESCRIPTION:                                                      */
/* REXX to work with the DSLIST (=3.4).                              */
/* Must be called from within DSLIST.                                */
/* To fill up all fields in the DSLIST panel, you must scroll to the */
/* left (or right) and to the bottom.                                */
/* %DSL X parm=value : eXclude Datasets from the list. parm can be   */
/*                     EXT (for extents), ORG, RECFM, LRECL, BLKSIZ  */
/*                     (for which the value must match) and CAT, VOL,*/
/*                     CDATE, EDATE, RDATE, DSN (for which value only*/
/*                     needs to be included). Always all matching    */
/*                     datasets will be excluded.                    */
/*                                                                   */
/* %DSL FLIP         : like FLIP in the editor you flip between      */
/*                     excluded and visible.                         */
/*                                                                   */
/* %DSL HR           : HSM RECALL will be send for all visible       */
/*                     migrated datasets. This is just an example    */
/*                     how to work with the DSLIST table.            */
/*                                                                   */
/* Example: Exclude all PDS  %DSL X ORG=PO                           */
/*                                                                   */
/* AUTHOR : Rainer Nowak                                             */
/* DATE   : 30.05.2013                                               */
/*                                                                   */
/*********************************************************************/
ARG p1 p2
SELECT
   WHEN p1 = 'X' THEN CALL Wue_DSL_X
   WHEN p1 = 'HR' THEN CALL Wue_DSLHR
   WHEN p1 = 'FLIP' THEN CALL Wue_DSL_Flip
   OTHERWISE DO
    SAY 'WRONG PARM. ONLY X, HR OR FLIP ARE ALLOWED.'
   END
END
EXIT
/* ================================================================= */
/* === Subroutins ================================================== */
/* ================================================================= */

/* ================================================================= */
/* Pointer function                                                  */
/* ================================================================= */
PTR: RETURN C2D(STORAGE(D2X(ARG(1)),ARG(2)))
/* ================================================================= */
/* Routine to search all open tables - the heart of this REXX        */
/* ================================================================= */
/* get_OTab                                                          */
/* search the open tables of this ISPF screen.                       */
/* This REXX is based on TALLY from Gilbert Saint-flour (CBT File    */
/* 183). The used ISPF control blocks are not documented, so use is  */
/* of own risk.                                                      */
/*                                                                   */
/* The table of 3.4 has the name DSLnnnnn with variables:            */
/* ZUDSNS       ZUSIZE       ZUUS         ZUCDATE      ZUEDATE       */
/* ZURDATE      ZUDVOL       ZUDMVOL      ZUDEVICE     ZUCDAT2       */
/* ZUEDAT2      ZURDAT2      ZUORG        ZUX          ZURECFM       */
/* ZULRECL      ZUBLKSIZ     ZUSTAT       ZUDSPACU     ZULMSG        */
/* ZULOCVOL     ZUOBTATT     ZUOBTSPC     ZUOBTDAT     ZUDXSTAT      */
/* ZULCMDL      ZUD20V       ZUDVOL7      ZUCATNAM     ZUSIZEX       */
/* ZUXX         ZUOVF        ZUGFLAG      ZUEATR                     */
/* ================================================================= */
get_OTab:
ADDRESS ISPEXEC
"VGET ZENVIR"                      /* Retrieve ISPF version          */
IF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO
   ZMSG000S = 'ISPF is to old'
   ZMSG000L = 'You need at least ISPF 5.9. You have 'Zenvir
   "SETMSG MSG(ISPZ000)"
   EXIT
END
tcb    = PTR(540,4)             /* TCB (EXEC command)    PSATOLD  */
tcb    = PTR(tcb+132,4)         /* TCB (ISPTASK)         TCBOTC   */
fsa    = PTR(tcb+112,4)         /* first save area       TCBFSA   */
r1     = PTR(fsa+24,4)          /* ISPTASK's R1                   */
tld    = PTR(r1,4)              /* TLD address                    */
dta    = PTR(tld+076,4)         /* DTA address           TLDDTAP  */
start = dta + 196               /* Address of first table name    */
finished = 'NO'
otnr = 0
otab.0 = otnr
DO UNTIL finished = 'YES'
   tbl = STORAGE(D2X(start),8) /* Name of table */
   if C2X(LEFT(tbl,1)) = '00' then do
      finished = 'YES'
   end
   else do
      otnr = otnr + 1
      otab.0 = otnr
      otab.otnr.1 = tbl
      otab.otnr.2 = STORAGE(D2X(start+8),4)
      start = start + 12
   end
END
RETURN
/* ================================================================= */
/* Routine to exclude datasets from the list                         */
/* ================================================================= */
Wue_DSL_X:
CALL get_OTab
if otab.0 > 0 then do
   tbl = ''
   do i = 1 to otab.0
      if LEFT(otab.i.1,3) = 'DSL' then do
         tbl = otab.i.1
         i = otab.0 + 1
      end
   end
   if LEFT(tbl,3) = 'DSL' then do
      CALL X_parm
      IF parm = 'NIX' THEN DO
         "ISPEXEC SETMSG MSG(ISRZ001)"
         EXIT
      END
      ADDRESS ISPEXEC
      'CONTROL ERRORS RETURN'
      'TBTOP' tbl
      IF rc>0 THEN DO
         ZEDLMSG="TBTOP failed for table" tbl "RC="rc
         "ISPEXEC SETMSG MSG(ISRZ001)"
         EXIT 8
      END
      rows=0;processed=0                           /* Init counters */
      DO FOREVER
        'TBSKIP' tbl                               /* NEXT ROW      */
         IF rc>0 THEN LEAVE
         'TBGET' tbl                               /* SET VARIABLES */
         IF rc>0 THEN LEAVE
         rows=rows+1                               /* count rows    */
         IF zudxstat = 'N' THEN DO
            IF parm = 'ALL' THEN DO
               zudxstat = 'Y'
               'TBPUT' tbl                         /* PUT VARIABLES */
               IF RC = 0 THEN processed=processed + 1
            END
            ELSE DO
             IF match = 'IN' THEN DO
               IF POS(matchvalue,VALUE(parm)) > 0 THEN DO
                  zudxstat = 'Y'
                  'TBPUT' tbl                      /* PUT VARIABLES */
                  IF RC = 0 THEN processed=processed + 1
               END
             END
             ELSE DO
               IF VALUE(parm) = matchvalue THEN DO
                  zudxstat = 'Y'
                  'TBPUT' tbl                      /* PUT VARIABLES */
                  IF RC = 0 THEN processed=processed + 1
               END
             END
            END
         END
      END
      ZEDLMSG="EXCLUDE for "processed" of "rows" datasets performed."
      IF processed = 0 THEN DO
         ZEDLMSG=ZEDLMSG!!" Use LEFT and DOWN to fill up the fields!"
      END
      ZEDSMSG="EXCLUDE performed!!"
      "ISPEXEC SETMSG MSG(ISRZ001)"
      "ISPEXEC CONTROL NONDISPL ENTER" /* skip one ENTER         */
   end
   else do
      ZEDLMSG="DSL X must be called in DSLIST (=3.4)."
      "ISPEXEC SETMSG MSG(ISRZ001)"
      EXIT 8
   end
end
else do
   ADDRESS ISPEXEC
   ZMSG000S = 'No open tables'
   ZMSG000L = 'No open tables can be found.'
   "SETMSG MSG(ISPZ000)"
end
RETURN
/* ================================================================= */
/* Routine to validate parm=value in DSL X parm=value                */
/* ================================================================= */
X_parm:
IF p2 = '' THEN DO
   parm = 'ALL'
END
ELSE DO
   PARSE VAR p2 parm '=' matchvalue
   match = 'IN'
   SELECT
      WHEN parm = 'VOL' THEN DO   /* Volser                          */
         parm = 'ZUDVOL7'
      END
      WHEN parm = 'EXT' THEN DO   /* Extents                         */
         parm = 'ZUX'
         match = 'EQ'
      END
      WHEN parm = 'ORG' THEN DO   /* Dataset organisation            */
         parm = 'ZUORG'
         match = 'EQ'
      END
      WHEN parm = 'RECFM' THEN DO   /* Recordformat                  */
         parm = 'ZURECFM'
         match = 'EQ'
      END
      WHEN parm = 'LRECL' THEN DO   /* Recordlength                  */
         parm = 'ZULRECL'
         match = 'EQ'
      END
      WHEN parm = 'BLKSIZ' THEN DO   /* Blocksize                    */
         parm = 'ZUBLKSIZ'
         match = 'EQ'
      END
      WHEN parm = 'CAT' THEN parm = 'ZUCATNAM'   /* Catalogname      */
      WHEN parm = 'CDATE' THEN parm = 'ZUCDATE'  /* Creation Date    */
      WHEN parm = 'EDATE' THEN parm = 'ZUEDATE'  /* Expiration Date  */
      WHEN parm = 'RDATE' THEN parm = 'ZURDATE'  /* Last Reference   */
      WHEN parm = 'DSN' THEN parm = 'ZUDSNS'     /* Dataset name     */
      OTHERWISE DO
         ZEDLMSG="Wrong Parm :"parm
         parm = 'NIX'
      END
   END
END
RETURN
/* ================================================================= */
/* Routine to flip between excluded and visible                      */
/* ================================================================= */
Wue_DSL_Flip:
CALL get_OTab
if otab.0 > 0 then do
   tbl = ''
   do i = 1 to otab.0
      if LEFT(otab.i.1,3) = 'DSL' then do
         tbl = otab.i.1
         i = otab.0 + 1
      end
   end
   if LEFT(tbl,3) = 'DSL' then do
      ADDRESS ISPEXEC
      'CONTROL ERRORS RETURN'
      'TBTOP' tbl
      IF rc>0 THEN DO
         ZEDLMSG="TBTOP failed for table" tbl "RC="rc
         "ISPEXEC SETMSG MSG(ISRZ001)"
         EXIT 8
      END
      rows=0;processed=0                           /* Init counters */
      DO FOREVER
        'TBSKIP' tbl                               /* NEXT ROW      */
         IF rc>0 THEN LEAVE
         'TBGET' tbl                               /* SET VARIABLES */
         IF rc>0 THEN LEAVE
         rows=rows+1                               /* count rows    */
         IF zudxstat = 'N' THEN DO
            zudxstat = 'Y'
         END
         ELSE DO
            zudxstat = 'N'
         END
         'TBPUT' tbl                               /* PUT VARIABLES */
         IF RC = 0 THEN processed=processed + 1
      END
      ZEDLMSG="FLIP for "processed" of "rows" datasets performed."
      ZEDSMSG="FLIP performed!!"
      "ISPEXEC SETMSG MSG(ISRZ001)"
      "ISPEXEC CONTROL NONDISPL ENTER" /* skip one ENTER             */
   end
   else do
      ZEDLMSG="DSL FLIP must be called in DSLIST (=3.4)."
      "ISPEXEC SETMSG MSG(ISRZ001)"
      EXIT 8
   end
end
else do
   ADDRESS ISPEXEC
   ZMSG000S = 'No open tables'
   ZMSG000L = 'No open tables can be found.'
   "SETMSG MSG(ISPZ000)"
end
RETURN
/* ================================================================= */
/* Routine to RECALL a list of datasets                              */
/* ================================================================= */
Wue_DSLHR:
CALL get_OTab
if otab.0 > 0 then do
   tbl = ''
   do i = 1 to otab.0
      if LEFT(otab.i.1,3) = 'DSL' then do
         tbl = otab.i.1
         i = otab.0 + 1
      end
   end
   if LEFT(tbl,3) = 'DSL' then do
      ADDRESS ISPEXEC
      'CONTROL ERRORS RETURN'
      'TBTOP' tbl
      IF rc>0 THEN DO
         ZEDLMSG="TBTOP failed for table" tbl "RC="rc
         "ISPEXEC SETMSG MSG(ISRZ001)"
         EXIT 8
      END
      rows=0;processed=0                           /* Init counters */
      DO FOREVER
        'TBSKIP' tbl                               /* NEXT ROW      */
         IF rc>0 THEN LEAVE
         'TBGET' tbl                               /* SET VARIABLES */
         IF rc>0 THEN LEAVE
         rows=rows+1                               /* count rows    */
         IF LEFT(zudvol7,6) = 'MIGRAT' & zudxstat = 'N' THEN DO
            dsn = STRIP(zudsns,'B',' ')
            ret = Wue_HR_Func(dsn)
            IF ret = 9 THEN DO
               say "Dataset "dsn" is not migrated."
            END
            processed=processed + 1
         END
      END
      ZEDLMSG="RECALL for "processed" of "rows" datasets was send."
      "ISPEXEC SETMSG MSG(ISRZ001)"
   end
   else do
      ZEDLMSG="DSL HR must be called in DSLIST (=3.4)."
      "ISPEXEC SETMSG MSG(ISRZ001)"
      EXIT 8
   end
end
else do
   ADDRESS ISPEXEC
   ZMSG000S = 'No open tables'
   ZMSG000L = 'No open tables can be found.'
   "SETMSG MSG(ISPZ000)"
end
RETURN
/* ================================================================= */
/* Function to send HRECALL for one dataset                          */
/* ================================================================= */
Wue_HR_Func:
PROCEDURE
ARG dsn
pref = SYSVAR(SYSPREF)
ADDRESS TSO
"profile noprefix"
retcode = LISTDSI("'"dsn"' DIRECTORY SMSINFO NORECALL")
if SYSREASON = 9 then do   /* dataset migrated */
   "HRECALL ('"dsn"') NOWAIT"
   ret = RC
end
else do
   ret = 9
END
ADDRESS TSO
if pref = '' then "profile noprefix"
else "profile prefix("pref")"
return ret
./ ADD NAME=STEMEDIT 0100-13230-13230-1410-01242-01242-00000-RNOWAK
//GILBERTV JOB (ACCT#),STEMEDIT,
// NOTIFY=&SYSUID,
// CLASS=A,MSGCLASS=H,COND=(0,NE)
//HLASM EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)
***********************************************************************
*                                                                     *
* MODULE NAME = STEMEDIT                                              *
*                                                                     *
* DESCRIPTIVE NAME = Display REXX Stem Variables using BRIF or VIIF.  *
*                                                                     *
* STATUS = R208                                                       *
*                                                                     *
* FUNCTION = This assembler sub-routine can be invoked by a REXX      *
*            EXEC to display the contents of stem variables using     *
*            the ISPF BRIF, VIIF or EDIT services.  STEMEDIT is       *
*            a nice complement to the REXX OUTTRAP function,          *
*            when it is used in the ISPF/PDF environment.             *
*                                                                     *
*            STEMEDIT can also PULL lines from the data stack         *
*            instead of using stem variables.  This only works        *
*            with EDIT or VIEW, i.e. not with BROWSE.                 *
*                                                                     *
* R208       STEMEDIT can be used to view or edit all variables.      *
* R208       Together with "TRACE ?R" STEMEDIT can be used for        *
* R208       debugging your REXX programs.                            *
*                                                                     *
* AUTHOR = Gilbert Saint-Flour <carlosºgsf-soft.com>                  *
*          http://gsf-soft.com/Freeware/                              *
*                                                                     *
* ENVIRONMENT = SEE BELOW                                             *
*                                                                     *
*    DEPENDENCIES: OS/390 R10 or z/OS                                 *
*                  ISPF/PDF V3 (or above)                             *
*                                                                     *
* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *
*                                                                     *
*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *
*                IBM HIGH LEVEL ASSEMBLER/MVS                         *
*                                                                     *
*    MODULE SIZE = 2K                                                 *
*                                                                     *
*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *
*                 PROBLEM STATE, KEY 8                                *
*                 APF AUTHORIZATION: NONE                             *
*                                                                     *
* SYNTAX  =  See below                                                *
*                                                                     *
*    CALL STEMEDIT  service,                                          *
*                   stemname                                          *
*                   <,firstelem>                                      *
*                   <,stemcount>                                      *
*                   <,title>                                          *
*                   <,panel>                                          *
*                   <,lrecl>                                          *
*                   <,recfm>                                          *
*                   <,profile>                                        *
* R208              <,varl>                                           *
*                                                                     *
*    Arguments:                                                       *
*                                                                     *
*         service   This argument must be coded as 'BROWSE', 'VIEW'   *
*                   or 'EDIT'.  It indicates which of the BRIF,       *
*                   VIIF or EDIF services will be used for display.   *
*                                                                     *
*                   If the BROWSE service is requested, the user can  *
*                   enter the V commands on the BROWSE screen to      *
*                   switch to VIEW.  This allows the data to be       *
*                   saved using CREATE/REPLACE, CUT or ROUTE.         *
*                                                                     *
*         stemname  the stem of the family of variables to display.   *
*                   The combined lengths of the stemname argument     *
*                   and the largest subscript (plus the period, if    *
*                   specified) cannot exceed 80 characters.           *
*                   If stemname is a true REXX stem, code a period    *
*                   as the last character.  If you do not specify     *
*                   the period, the subscripts will be concatenated   *
*                   to the stem name without an intervening period.   *
*                   For example, if you specify a stemname of "ABC.", *
*                   STEMEDIT will look for variables of the form      *
*                   "ABC.1", "ABC.2", etc. If you specify a stemname  *
*                   of "XYZ" (no period), STEMEDIT will look for      *
*                   variables of the form "XYZ1", "XYZ2", etc.        *
*                                                                     *
*                   If the service is coded as "VIEW" or "EDIT" and   *
*                   stemname is omitted, STEMEDIT PULLs lines from    *
*                   the stack.                                        *
* R208              If the service is coded as "VIEW" or "EDIT"       *
* R208              stemname can be coded as "*", which will display  *
* R208              all variables in the REXX variable pool. Variable *
* R208              names will be shown with 39 characters, except you*
* R208              code varl as "L", showing variable names with 255 *
* R208              characters. If variable name is longer, it will   *
* R208              be abbreviated to 38 or 254 characters and        *
* R208              suffixed with "*". Last variable is always the    *
* R208              contents of VARNAME from this program.            *
* R208              If the service is coded as "EDIT" and stemname    *
* R208              is coded as "*", variables can be edited. It must *
* R208              be coded with variable name beginning in colume   *
* R208              1, some blanks endet with "=" and immediately     *
* R208              followed by the value, which must be ended with   *
* R208              "00"x. You can also drop a variable or a stem     *
* R208              by coding "DROP variablename" at the beginning    *
* R208              of the line and end it with "00"x.                *
* R208              Variable name can have a length up to 250.        *
*                                                                     *
*         firstelem the element of the pseudo-array to begin the      *
*                   display on.  The default value is element 1.      *
*                                                                     *
*         stemcount the number of elements to display.                *
*                   If you do not specify stemcount, STEMEDIT will    *
*                   display variables beginning with firstelem, and   *
*                   continuing until an un-initialized variable is    *
*                   found (i.e., a variable which has its name for    *
*                   a value).                                         *
*                                                                     *
*         title     an arbitrary character string which identifies    *
*                   the data which is being displayed.  The maximum   *
*                   length of this string is 54 characters.           *
*                                                                     *
*         panel     a 1 to 8 character name of the panel member       *
*                   to use for the display.                           *
*                   The default panel is ISRBROBA for BROWSE          *
*                   and ISREDDE2 for VIEW and EDIT.                   *
*                                                                     *
*         lrecl     the record length that should be passed to        *
*                   the BRIF, VIIF or EDIF services.                  *
*                   The default value is 255.                         *
*                                                                     *
*         recfm     the record format that should be passed to        *
*                   the BRIF, VIIF or EDIF services.                  *
*                   Possible values are F, FA, FM, V, VA, VM, or U.   *
*                   The default value is V.                           *
*                                                                     *
*         profile   the 8-char name of the profile that should be     *
*                   used by VIIF and EDIF when the VIEW or EDIT       *
*                   services are requested.                           *
*                   The default value is TEXT.                        *
*                                                                     *
* R208    varl      form of the variable list, if varname is *.       *
* R208              Can be S for short (=39 char) or L for long       *
* R208              (=255 char) varnames.                             *
*                                                                     *
*    Examples:                                                        *
*                                                                     *
*         Call the STEMEDIT routine to display the output of the      *
*         TSO "LISTCAT" command.  The variables to display            *
*         begin with the characters "LINE.":                          *
*                                                                     *
*            CALL OUTTRAP 'LINE.'                                     *
*            "LISTCAT"                                                *
*            CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'          *
*                                                                     *
*         QUEUE JCL to the data stack and call the STEMEDIT           *
*         routine to VIEW it:                                         *
*                                                                     *
*            "MAKEBUF"                                                *
*            QUEUE '//MYJOB JOB 12345,CLASS=A'                        *
*            QUEUE '//STEP2 EXEC PGM=IEFBR14'                         *
*            CALL STEMEDIT 'VIEW',,,,'Sample JCL'                     *
*            "DROPBUF"                                                *
*                                                                     *
* RETURN-CODES = See below                                            *
*                                                                     *
*        The STEMEDIT function returns a return code that indicates   *
*        whether the display worked.  The returned value is           *
*        contained in the RC special variable.                        *
*                                                                     *
*        The following STEMEDIT return code values are possible:      *
*                                                                     *
*        0    The display was successful.                             *
*                                                                     *
*        4    There were no stems matching the description given in   *
*             stemname (BROWSE).  The data was not modified (EDIT).   *
*                                                                     *
*        8    Option incompatible with requested service.             *
*                                                                     *
*        12   Invalid Service requested.                              *
*                                                                     *
*        16   BRIF, VIIF or EDIF failed.                              *
*                                                                     *
* USAGE NOTES = See below                                             *
*                                                                     *
*        The EDIT service only works with a stem variable.            *
*        If the data is modified by the user, STEMEDIT DROPs the      *
*        stem variable, sets stem.0 to the number of records          *
*        written, copies records to the stem.1 through stem.n         *
*        where n is equal to the value of the stem.0 variable,        *
*        and sets the RC variable to 0.  If the data is not           *
*        modified by the user, STEMEDIT sets the RC variable to 4.    *
*                                                                     *
* COMPATIBILITY                                                       *
*                                                                     *
*        STEMEDIT has been designed to be compatible with             *
*        the STEMDISP function of the REXXTOOLS product from          *
*        Open Software Technologies, with the following               *
*        exceptions:                                                  *
*                                                                     *
*        1. STEMEDIT supports the BROWSE, VIEW and EDIT services      *
*           (STEMDISP only supports BROWSE).                          *
*                                                                     *
*        2. If stemcount is not specified, STEMEDIT scans             *
*           variables until an unitialised variable is found.         *
*           (STEMDISP stops after 100000 variables).                  *
*                                                                     *
*        3. STEMEDIT has the ability to retrieve data from a          *
*           stem variable or the data stack (STEMDISP can only        *
*           retrieve data from a stem variable).                      *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
* 100 Initial release                                            1995 *
* 101 Fix S0C4 in RDRTNE                                         1996 *
* 102 VIEW support via EDIF                                           *
* 103 Convert 2nd argument to uppercase (variable name)               *
*     Add support for 3rd and 4th arguments                           *
* 104 Change module name from STEMDISP to STEMVIEW               1997 *
*     Punch ' ALIAS STEMDISP ' for compatibility with REXXTOOLS       *
*     Change name of EDIT function to VIEW                            *
*     Issue CONTROL DISPLAY REFRESH before BROWSE/EDIT                *
*     Pass address of environment block to IRXEXCOM                   *
* 105 PULL data from the stack when no variable name specified        *
*     Prompt user before saving data in VIEW mode                     *
*     LRECL can be specified in 7th argument                          *
*     Check for missing parms to prevent S0C4                         *
*     Replace STRING macro with in-line code                          *
*     Accept SHVTRUNC as valid RC from IRXEXCOM                       *
* 106 Truncate Title                                                  *
* 107 E or V command switches from BROWSE to VIEW                1999 *
* 108 Set ZVMODET='VIEW' to show VIEW instead of EDIT on ISREDDEx     *
*     Add recfm and profile parameters for VIEW                       *
*     Display error message after BRIF/EDIF failure                   *
*     Display STEMVIEW Arguments Syntax if not invoked from REXX      *
* 201 Program name changed from STEMVIEW to STEMEDIT             2002 *
*     Use VIIF instead of EDIF (OS/390 R10 and z/OS)                  *
*     Add EDIT function for stem variables                            *
*     Maximum length of variable name increased to 255                *
*     Maximum length of data line increased to 32760                  *
* 202 Set default LRECL to 255                                   2003 *
* 203 Force default panel names - ISRBROBA/ISREDDE2              2009 *
*     Use SAVE3 in RDRTNE and WRITERTN                                *
*     Move LINE fld to own DSECT                                      *
*     When invoked for BROWSE and user issues V or E :                *
*     1. Issue CONTROL DISPLAY SAVE/RESTORE                           *
*     2. Clear Panel Name                                             *
* 204 Change X'40' to X'41' (NBSP) in TITLE                           *
* 205 Add support for ISPF V3                                         *
*     Replace LINK macro with ISPLINK                                 *
* 206 Check for empty records in RDRTN84                         2010 *
* 207 VIIF only supported in ISPF V5 and above                        *
*                                                                     *
* 208 List all Variables, stemname=*                       2013 R208  *
*     Remove ORG instruction from R206 (this had made STEMCOUNT R208  *
*     to an LASTELEMENT)                                        R208  *
*     Change at label RDRTN88 to prevent display of empty lines R208  *
*     when BROWSE is invoked with first element specified.      R208  *
*     EDIT of variables.                                        R208  *
*                                                                     *
&REL     SETC  'R208'                                                 *
***********************************************************************
         PUNCH ' ALIAS STEMDISP (compatibility with REXXTOOLS) '
         PUNCH ' ALIAS STEMVIEW (compatibility with STEMVIEW) '
STEMEDIT CSECT
STEMEDIT RMODE 24                      For TPUT
STEMEDIT AMODE 31
&D       SETC  '&SYSDATE'(7,2)'-'.'&SYSDATE'(1,2)'-'.'&SYSDATE'(4,2)
         SAVE  (14,12),,'GSF Utilities - STEMEDIT &REL - 20&D &SYSTIME'
         LR    R12,R15
         USING STEMEDIT,R12
*---------------------------------------------------------------------*
*                                                                     *
*        ALLOCATE DYNAMIC STORAGE                                     *
*                                                                     *
*---------------------------------------------------------------------*
         GETMAIN RU,LV=DYNAML,         Allocate Dynamic Storage Area   X
               LOC=BELOW,              24-bit address for TPUT         X
               BNDRY=PAGE
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LA    R14,72(,R1)             CLEAR WORKING STORAGE
         LA    R15,DYNAML-72           CLEAR WORKING STORAGE
         SLR   R1,R1                   CLEAR WORKING STORAGE
         MVCL  R14,R0                  CLEAR WORKING STORAGE
         LM    R13,R1,8(R13)           SET R13, RELOAD R1
         USING DYNAM,R13
         STM   R15,R1,R15R0R1          save regs for cmd rtne
         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST
         MVI   BLANKS,C' '             a bunch of blanks
         MVC   BLANKS+1(L'BLANKS-1),BLANKS
         MVC   TITLE,BLANKS            default title
         MVC   PANEL_NAME,BLANKS       default panel name
         MVI   STEMCOUNT,1             default count: X'01000000'
         GETMAIN RU,LV=L'LINE+256,     Alloc Dynamic Storage Area  R208X
               BNDRY=PAGE
         STM   R0,R1,LINE_LEN_ADDR     Save length/address
         LR    R9,R1                   Copy A(LINE)
         USING LINE_DSECT,R9
*---------------------------------------------------------------------*
*                                                                     *
*        BUILD THE SHVBLOCK                                           *
*                                                                     *
*---------------------------------------------------------------------*
         LA    R10,DYNAM_SHVB
         USING SHVBLOCK,R10
         MVI   SHVCODE,SHVFETCH        FETCH VARIABLE
         LH    R0,=Y(L'LINE)           LENGTH OF 'FETCH' VALUE BUFFER
         ST    R0,SHVBUFL              LENGTH OF 'FETCH' VALUE BUFFER
         LA    R0,255                  default lrecl for BRIF/VIIF/EDIF
         ST    R0,LRECL                default lrecl for BRIF/VIIF/EDIF
         MVC   RECFM,=C'V '            default RECFM is V
         MVC   PROFILE_NAME,=CL8'TEXT' default profile name
         LA    R0,LINE                 ADDRESS OF VALUE BUFFER
         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER
         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME
         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME
         L     R15,ADDR_OF_ENVBLOCK    Environment block
         CLC   =C'ENVBLOCK',0(R15)     Invoked from REXX?
         BNE   NOREXX                  no, quit
         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)
         L     R15,IRXEXCOM-IRXEXTE(,R15)          A(IRXEXCOM)
         L     R0,ADDR_OF_ENVBLOCK     ENVIRONMENT BLOCK
         LA    R1,IRXEXCOM_PARM        parm list
         STM   R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)
         LA    R14,=C'IRXEXCOM'        Shared Variable Routine
         SLR   R15,R15                 PARM2=0
         SLR   R0,R0                   PARM3=0
         LA    R1,SHVBLOCK             PARM4
         STM   R14,R1,IRXEXCOM_PARM    build parm list for IRXEXCOM
         OI    IRXEXCOM_PARM+12,X'80'  VL=1
*---------------------------------------------------------------------*
         MACRO                                                    macro
&NAME    ISPLINK &OPRNDS,&ERRET=                                  macro
         GBLB  &IHBSWA                                            macro
&IHBSWA  SETB  1                       VL=1                       macro
&NAME    LA    R1,PARMLIST             parm list                  macro
         IHBOPLST ,&OPRNDS,MF=(E,(1))                             macro
         L     R15,ISPLINKº            ISPLINK bootstrap
         BALR  R14,R15                 invoke ISPLINK
         AIF   (T'&ERRET EQ 'O').MEND                             macro
         LTR   R15,R15                 Any error?
         BNZ   &ERRET                  yes, jump
.MEND    MEND                                                     macro
*---------------------------------------------------------------------*
*                                                                     *
*        PROCESS ARGUMENTS                                            *
*                                                                     *
*---------------------------------------------------------------------*
         LOAD  EP=ISPLINK              preload ISPLINK
         ST    R0,ISPLINKº             A(ISPLINK)
         LA    R0,L'ZENVIR
         ST    R0,DWD
         ISPLINK ($VCOPY,$ZENVIR,DWD,ZENVIR,$MOVE)
*
* Set VAR1 to Blank for further compares                           R208
         MVI   VAR1,C' '                                           R208
* Set VARL to 'S' for further compares                             R208
         MVI   VARL,C'S'                                           R208
*
         LM    R2,R3,8*1-8(R11)        1st ARG (BROWSE/EDIT)
         LTR   R3,R3                   service specified?
         BNP   ARG1N                   no, error
         CH    R3,=AL2(L'SERVICE)      name too long?
         BH    ARG1N                   yes, error
         BCTR  R3,0                    prepare "EX"
         MVC   SERVICE(*-*),0(R2)      move string
         EX    R3,*-6                  execute MVC
         OC    SERVICE,BLANKS          convert to uppercase
*
         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?
         BL    ARG1G                   no, keep blank panel name
         MVC   PANEL_NAME,=C'ISRBROBA' default panel name (BROWSE)
ARG1G    EQU   *
         CLC   =C'BROWSE',SERVICE      BROWSE?
         BE    ARG1X                   yes, exit
         CLI   ZENVIR+5,C'4'           ISPF V4 or above ?
         BL    ARG1J                   no, keep blank panel name
         MVC   PANEL_NAME,=C'ISREDDE2' default panel name (VIEW/EDIT)
ARG1J    EQU   *
         CLC   =C'VIEW  ',SERVICE      VIEW?
         BE    ARG1X                   yes, exit
         CLC   =C'EDIT  ',SERVICE      EDIT?
         BE    ARG1X                   yes, exit
ARG1N    EQU   *                       bad service specified
         B     EXIT12                  no service, exit with RC=12
ARG1X    EQU   *
*
         LM    R2,R3,8*2-8(R11)        2ND ARG (VAR NAME)
         STM   R2,R3,STEMNAME          2ND ARG (VAR NAME)
         LTR   R3,R3                   stemname specified?
         BNP   ARG2N                   no, jump
         MVC   VAR1,0(R2)              first char of varname       R208
         OI    0(R2),X'40'             convert to uppercase
         LA    R2,1(,R2)               convert to uppercase
         BCT   R3,*-8                  convert to uppercase
         CLI   VAR1,C'*'               is varname '*' ?            R208
         BE    ARG2RN                  yes, go to ARG2RN           R208
         B     ARG2X
ARG2N    EQU   *                       no stemname specified
         CLI   SERVICE,C'B'            SERVICE=BROWSE?
         BE    EXIT8                   yes, exit with RC=8
         CLI   SERVICE,C'E'            SERVICE=EDIT?
         BE    EXIT8                   yes, exit with RC=8
         LA    R14,=CL8'PULL'          FUNCTION
         LA    R15,SHVVALA             ADDRESS OF DATA RETURNED
         LA    R0,SHVVALL              LENGTH OF DATA RETURNED
         LA    R1,VALUE                VALUE RETURNED BY IRXSTK
         LA    R2,ADDR_OF_ENVBLOCK     Environment block
         LA    R3,RETCODE              RETURN CODE
         STM   R14,R3,IRXSTK_PARM      BUILD PARM LIST
         OI    IRXSTK_PARM+20,X'80'    BUILD PARM LIST
         B     ARG2X                   Jump over ARG2RN            R208
ARG2RN   EQU   *                                                   R208
         CLI   SERVICE,C'B'            SERVICE=BROWSE?             R208
         BE    EXIT8                   yes, exit with RC=8         R208
         MVI   SHVCODE,SHVNEXTV        FETCH NEXT VARIABLE         R208
ARG2X    EQU   *
*
         LM    R2,R3,8*3-8(R11)        3rd ARG (first element)
         LTR   R3,R3                   zero length?
         BZ    ARG3X                   yes, jump
         BM    ARG10X                  eof, exit                   R208
         BCTR  R3,0                    decrement
         PACK  DWD,0(,R2)              *executed*
         EX    R3,*-6                  pack the value
         CVB   R0,DWD                  make it binary
         BCTR  R0,0                    relative to zero
         ST    R0,CURRECNO             save it for later
ARG3X    EQU   *
*
         LM    R2,R3,8*4-8(R11)        4th ARG (stem count)
         LTR   R3,R3                   zero length?
         BZ    ARG4X                   yes, jump
         BM    ARG10X                  eof, exit                   R208
         BCTR  R3,0                    decrement
         PACK  DWD,0(,R2)              *executed*
         EX    R3,*-6                  pack the value
         CVB   R0,DWD                  make it binary
         AL    R0,CURRECNO             add origin
*        ORG   *-4                                                 R208
         ST    R0,STEMCOUNT            save it for later
ARG4X    EQU   *
*
         LM    R2,R3,8*5-8(R11)        5TH ARG (TITLE)
         LTR   R3,R3                   zero length?
         BZ    ARG5X                   yes, jump
         BM    ARG10X                  eof, exit                   R208
         LA    R1,TITLE                start of output area
         CH    R3,=Y(L'TITLE)          title too long?
         BNH   ARG5M                   no, jump
         LH    R3,=Y(L'TITLE)          yes, truncate it
*LOOP
ARG5M    MVC   0(1,R1),0(R2)           move one character
         CLI   0(R1),X'40'             X'40' -> X'41' (NBSP)
         BNE   *+8                     X'40' -> X'41' (NBSP)
         MVI   0(R1),X'41'             X'40' -> X'41' (NBSP)
         LA    R1,1(,R1)               next output char
         LA    R2,1(,R2)               next input char
         BCT   R3,ARG5M                move title, one char at a time
*ENDLOOP
ARG5X    EQU   *
*
         LM    R2,R3,8*6-8(R11)        6TH ARG (PANEL)
         LTR   R2,R2                   SPECIFIED?
         BZ    ARG6X                   no, jump
         BM    ARG10X                  eof, exit                   R208
         BCTR  R3,0                    prepare "EX"
         MVC   PANEL_NAME(*-*),0(R2)   move string
         EX    R3,*-6                  execute MVC
ARG6X    EQU   *
*
         LM    R2,R3,8*7-8(R11)        7th ARG (lrecl)
         LTR   R3,R3                   zero length?
         BZ    ARG7X                   yes, jump
         BM    ARG10X                  eof, exit                   R208
         BCTR  R3,0                    decrement
         PACK  DWD,0(,R2)              *executed*
         EX    R3,*-6                  pack the value
         CVB   R0,DWD                  make it binary
         ST    R0,LRECL                save it for later
         CH    R0,=Y(L'LINE)           lrecl too big?
         BH    EXIT8                   yes, exit with RC=8
ARG7X    EQU   *
*
         LM    R2,R3,8*8-8(R11)        8TH ARG (recfm)
         LTR   R2,R2                   SPECIFIED?
         BZ    ARG8X                   no, jump
         BM    ARG10X                  eof, exit                   R208
         CLI   SERVICE,C'B'            SERVICE=BROWSE?
         BE    EXIT8                   yes, exit with RC=8
         CH    R3,=Y(L'RECFM)          too long?
         BH    EXIT8                   yes, exit with RC=8
         BCTR  R3,0                    prepare "EX"
         MVC   RECFM(*-*),0(R2)        move string
         EX    R3,*-6                  execute MVC
         OC    RECFM,BLANKS            upper-case
ARG8X    EQU   *
*
         LM    R2,R3,8*9-8(R11)        9TH ARG (profile)
         LTR   R2,R2                   SPECIFIED?
         BZ    ARG9X                   no, jump
         BM    ARG10X                  eof, exit                   R208
         CLI   SERVICE,C'B'            SERVICE=BROWSE?
         BE    EXIT8                   yes, exit with RC=8
         CH    R3,=Y(L'PROFILE_NAME)   too long?
         BH    EXIT8                   yes, exit with RC=8
         BCTR  R3,0                    prepare "EX"
         MVC   PROFILE_NAME(*-*),0(R2) move string
         EX    R3,*-6                  execute MVC
*
ARG9X    EQU   *                       S or L                      R208
*                                                                  R208
         LM    R2,R3,8*10-8(R11)       10TH ARG (S or L)           R208
         LTR   R2,R2                   SPECIFIED?                  R208
         BZ    ARG10X                  no, jump                    R208
         BM    ARG10X                  eof, exit                   R208
         CLI   SERVICE,C'B'            SERVICE=BROWSE?             R208
         BE    EXIT8                   yes, exit with RC=8         R208
         MVC   VARL,0(R2)              first char of varlistform   R208
         OC    VARL,BLANKS             convert to uppercase        R208
*
ARG10X   EQU   *                       end of arg list             R208
*
*---------------------------------------------------------------------*
*                                                                     *
*        Invoke BRIF, VIIF or EDIF Services                           *
*                                                                     *
*---------------------------------------------------------------------*
         ISPLINK ($CONTROL,$ERRORS,$RETURN) CONTROL ERRORS RETURN
         ISPLINK ($CONTROL,$DISPLAY,$REFRESH) CONTROL DISPLAY REFRESH
         LA    R0,SAVE2                PARM FOR READ ROUTINE
         ST    R0,SAVE2                PARM FOR READ ROUTINE
         LA    R2,RDRTNE               READ ROUTINE
         LA    R3,CMDRTNE              COMMAND ROUTINE
         LA    R4,WRITERTN             WRITE ROUTINE
         STM   R2,R4,RDCMDWR+0         READ,CMD,WRITE
         CLI   SERVICE,C'V'            SERVICE=VIEW?
         BE    VIIF                    yes, jump
         CLI   SERVICE,C'E'            SERVICE=EDIT?
         BE    EDIF                    yes, jump
         ISPLINK (=C'BRIF',            ISPF SERVICE                    X
               TITLE,                  DSNAME                          X
               RECFM,                  RECFM                           X
               LRECL,                  LRECL                           X
               RDCMDWR+0,              READ ROUTINE                    X
               RDCMDWR+4,              COMMAND ROUTINE                 X
               SAVE2,                  PARM FOR READ ROUTINE           X
               PANEL_NAME)             PANEL (ISRBROBF/ISRBROBA)
         CH    R15,=H'12'              empty data set?
         BNE   GOBACK                  no, jump
         LA    R7,4                    yes, RC=4 "no data to browse"
         B     GOBACK40
VIIF     EQU   *
         CLI   ZENVIR+5,C'5'           ISPF V5 or above ?
         BL    EDIF                    no, use EDIF instead of VIIF
         ISPLINK (=C'VIIF',            ISPF SERVICE                    X
               TITLE,                  DSNAME                          X
               PROFILE_NAME,           PROFILE NAME                    X
               RECFM,                  RECFM                           X
               LRECL,                  LRECL                           X
               RDCMDWR+0,              READ ROUTINE                    X
               0,                      COMMAND EXIT                    X
               SAVE2,                  PARM FOR READ ROUTINE           X
               0,                      Edit Length                     X
               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)
         B     GOBACK
EDIF     EQU   *
         ISPLINK (=C'EDIF',            ISPF SERVICE                    X
               TITLE,                  DSNAME                          X
               PROFILE_NAME,           PROFILE NAME                    X
               RECFM,                  RECFM                           X
               LRECL,                  LRECL                           X
               RDCMDWR+0,              READ ROUTINE                    X
               RDCMDWR+8,              WRITE ROUTINE                   X
               0,                      COMMAND EXIT                    X
               SAVE2,                  PARM FOR READ ROUTINE           X
               0,                      Edit Length                     X
               PANEL_NAME)             PANEL (ISREDDE2/ISREDDE3)
         LTR   R7,R15                  OK?
         BZ    GOBACK40                yes, jump
         CH    R7,=H'4'                Data Modified?
         BE    GOBACK40                no, exit with RC=4
*---------------------------------------------------------------------*
*                                                                     *
*        Set return code                                              *
*                                                                     *
*---------------------------------------------------------------------*
GOBACK   EQU   *
         LTR   R7,R15                  OK?
         BZ    GOBACK40                yes, jump
         CH    R7,=H'4'                Severe error in BRIF/VIIF/EDIF?
         BH    GOBACK16                yes, RC=16
         SLR   R7,R7                   no, RC=0
         B     GOBACK40
*
*        BRIF/VIIF/EDIF error: display error message
*
GOBACK16 LA    R7,1000(,R7)            RC=10nn: rc nn from BRIF/VIIF
         LA    R0,L'ZERRMSG            max length
         ST    R0,DWD                  max length
         ISPLINK ($VCOPY,$ZERRMSG,DWD,ZERRMSG,$MOVE),                  X
               ERRET=GOBACK40          No MSG, skip SETMSG
         ISPLINK ($SETMSG,ZERRMSG)
*---------------------------------------------------------------------*
*                                                                     *
*        Pass return code in RC variable                              *
*                                                                     *
*---------------------------------------------------------------------*
GOBACK40 EQU   *
         LA    R0,WORK80               ADDRESS OF VALUE BUFFER
         ST    R0,SHVVALA              ADDRESS OF VALUE BUFFER
         CVD   R7,DWD                  convert to decimal
         OI    DWD+7,15                convert to decimal
         UNPK  WORK80(5),DWD           convert to decimal
         LA    R15,5                   LENGTH OF VARIABLE NAME
         ST    R15,SHVVALL             length
         MVC   VARNAME(2),=C'RC'       variable name
         LA    R15,2                   LENGTH OF VARIABLE NAME
         ST    R15,SHVNAML             LENGTH OF VARIABLE NAME
         LA    R0,VARNAME              ADDRESS OF VARIABLE NAME    R208
         ST    R0,SHVNAMA              ADDRESS OF VARIABLE NAME    R208
         MVI   SHVCODE,SHVSTORE        STORE VARIABLE
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)
         BALR  R14,R15              <- Store REXX variable "RC"
         SLR   R7,R7                   RC=0
         B     EXIT
*---------------------------------------------------------------------*
*                                                                     *
*        STEMEDIT was not invoked from a REXX exec                    *
*        Display argument syntax using TPUT                           *
*                                                                     *
*---------------------------------------------------------------------*
NOREXX   EQU   *
         TPUT  SYNTAXMSG,L'SYNTAXMSG   display syntax
         LA    R7,20                   RC=20
         B     EXIT
*---------------------------------------------------------------------*
*                                                                     *
*        CLEAN-UP AND EXIT                                            *
*                                                                     *
*---------------------------------------------------------------------*
EXIT8    LA    R7,8                    RC=8 Option incompat w/service
         B     EXIT
EXIT12   LA    R7,12                   RC=12 Invalid Service
*
EXIT     LM    R0,R1,LINE_LEN_ADDR     Load length/address
         FREEMAIN RU,LV=(R0),A=(R1)    Free Dynamic Storage Area
         LR    R1,R13                  A(DYNAM)
         L     R13,4(,R13)
         FREEMAIN RU,LV=DYNAML,A=(R1)  Free Dynamic Storage Area
         LR    R15,R7                  pass return code
         RETURN (14,12),RC=(15)
         DROP
***********************************************************************
*                                                                     *
*        BRIF Command Routine                                         *
*                                                                     *
*        This routine is invoked by BRIF each time a command is       *
*        entered on the BROWSE screen.  If the user enters the E      *
*        or V command, then STEMEDIT reinvokes itself with VIEW       *
*        instead of BROWSE.                                           *
*                                                                     *
***********************************************************************
CMDRTNE  SAVE  (14,12),,*
         LR    R12,R15
         USING CMDRTNE,R12
         LR    R14,R13                 CALLER'S SAVE AREA
         L     R13,04(,R1)             PTR TO DIALOG DATA AREA
         L     R13,0(,R13)             A(SAVE2)
         ST    R14,4(,R13)             CHAIN SAVE AREAS
         ST    R13,8(,R14)             CHAIN SAVE AREAS
         USING SAVE2,R13
         L     R6,00(,R1)              Function Code
         L     R9,LINE_LEN_ADDR+4      A(LINE)
         USING LINE_DSECT,R9
         CLC   =F'20',0(R6)            UNKNOWN COMMAND?
         BNE   CMDRTNE4                NO, EXIT
         LA    R0,L'WORK80             max length of variable
         ST    R0,DWD                  max length of variable
         ISPLINK ($VCOPY,$ZCMD,DWD,WORK80,$MOVE)
         OC    WORK80(2),BLANKS        upper-case
         CLC   =C'E ',WORK80           ZCMD="E" ?
         BE    CMDRTNE7                yes, do it
         CLC   =C'V ',WORK80           ZCMD="V" ?
         BE    CMDRTNE7                yes, do it
CMDRTNE4 L     R13,4(,R13)             BRIF SAVE AREA
         RETURN (14,12),RC=4           ISPF will process the command
*
*        Invoke VIEW when user enters V or E during BROWSE display
*
CMDRTNE7 EQU   *
         ISPLINK ($CONTROL,$DISPLAY,$SAVE) CONTROL DISPLAY SAVE
*
         LM    R15,R1,R15R0R1          restore regs at entry
         L     R11,EFPLARG-EFPL(,R1)   ADDR OF ARG LIST
         LA    R2,$VIEW                service=VIEW
         LA    R3,L'$VIEW              length
         STM   R2,R3,0(R11)            update service name
         SLR   R2,R2                   R2=0
         SLR   R3,R3                   R3=0
         STM   R2,R3,8*6-8(R11)        6TH ARG (PANEL)
         BALR  R14,R15              <- re-invoke myself for VIEW
*
         ISPLINK ($CONTROL,$DISPLAY,$RESTORE) CONTROL DISPLAY RESTORE
*
         L     R13,4(,R13)             BRIF SAVE AREA
         RETURN (14,12),RC=0           command processed
         DROP
***********************************************************************
*                                                                     *
*        BRIF/VIIF READ Routine                                       *
*                                                                     *
*        This routine is invoked by BRIF and VIIF to                  *
*        return the address of a record.                              *
*                                                                     *
***********************************************************************
RDRTNE   SAVE  (14,12),,*
         LR    R12,R15
         USING RDRTNE,R12
         LR    R14,R13                 CALLER'S SAVE AREA
         L     R13,12(,R1)             PTR TO DIALOG DATA AREA
         L     R13,0(,R13)             A(SAVE2)
         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)
         ST    R14,4(,R13)             CHAIN SAVE AREAS
         ST    R13,8(,R14)             CHAIN SAVE AREAS
         USING SAVE3,R13
         L     R6,00(,R1)              RECORD DATA READ
         L     R7,04(,R1)              LENGTH
         L     R4,08(,R1)              RELATIVE RECORD NUMBER
         L     R9,LINE_LEN_ADDR+4      A(LINE)
         USING LINE_DSECT,R9
         CLI   SERVICE,C'V'            VIIF?
         BE    RDRTNE06                YES, JUMP
         CLI   SERVICE,C'E'            EDIF?
         BE    RDRTNE06                YES, JUMP
         L     R5,0(,R4)               LINE NUMBER REQUESTED BY BRIF
         AL    R5,CURRECNO             add first element (4th arg)
         B     RDRTNE07
RDRTNE06 EQU   *
         LA    R5,1                    NEXT LINE FOR EDIT
         AL    R5,CURRECNO             RECORD NUMBER
         ST    R5,CURRECNO             RECORD NUMBER
RDRTNE07 EQU   *
*
         LA    R10,DYNAM_SHVB
         USING SHVBLOCK,R10
         CL    R5,STEMCOUNT            end reached?
         BH    RDRTN79                 yes, exit with RC=8
         CLI   SHVRET,SHVLVAR          last variable to fetch?     R208
         BE    RDRTN79                 yes, exit with RC=8         R208
*
*        Retrieve value of current variable
*
         BAL   R14,FETCHVAR         <- retrieve stemmed variable
         CLI   SHVRET,SHVCLEAN         OK?
         BE    RDRTN70                 yes, pass line to BRIF
         CLI   SHVRET,SHVTRUNC         truncated value?
         BE    RDRTN70                 yes, pass line to BRIF
         CLI   SHVRET,SHVNEWV          this variable exists?
         BE    RDRTN80                 NO, EXIT
*
*        If IRXEXCOM fails, display R15 and SHVRET values.
*
         MVC   LINE(L'VARNAME),VARNAME move variable name
         L     R1,SHVNAML              length of variable name
         LA    R2,LINE(R1)             length of variable name
         MVC   0(5,R2),=C' R15='       move literal
         CVD   R15,DWD                 save return code
         OI    DWD+7,15                convert to decimal
         UNPK  5(3,R2),DWD             move return code: R15=008
         MVC   8(8,R2),=C',SHVRET='    move literal
         UNPK  16(3,R2),SHVRET(2)      hex display
         TR    16(2,R2),HEXTAB-240     hex display
         LA    R15,18(,R1)             data length
         ST    R15,SHVVALL             length
*
*        Return value of variable
*
RDRTN70  L     R0,SHVVALA              DATA ADDRESS
         L     R1,SHVVALL              DATA LENGTH
         CLI   VAR1,C'*'               Fetch all vars?             R208
         BNE   RDRTN72                 No, jump over next lines    R208
         CLI   VARL,C'L'               Show long var name?         R208
         BE    RDRTN71L                yes, jump over next lines   R208
         MVI   LVARN,C' '              Clear LVARN                 R208
         MVC   LVARN+1(39),LVARN                                   R208
         L     R3,SHVNAML              length of variable name     R208
         CL    R3,=F'39'               var name longer than 39?    R208
         BH    RDRTN71                 if longer jump              R208
         BCTR  R3,0                    prepare "EX"                R208
         MVC   LVARN(*-*),VARNAME      move variable name          R208
         EX    R3,*-6                  execute MVC                 R208
         B     RDRTN71E                                            R208
RDRTN71  EQU   *                                                   R208
         MVC   LVARN(38),VARNAME       move variable name          R208
         MVI   LVARN+38,C'*'           move * to end of var name   R208
RDRTN71E EQU   *                                                   R208
         MVI   LVARN+39,C'='           move = after var name       R208
         LA    R3,40                   R3=40                       R208
         LA    R14,LINE                "to" address                R208
         L     R15,LRECL               "to" length                 R208
         SR    R15,R3                  length - 40                 R208
         MVCL  R14,R0                  move data to LINE           R208
         LA    R0,LINEA                DATA ADDRESS incl. varname  R208
         L     R1,LRECL                DATA LENGTH                 R208
         B     RDRTN72                 jump over next lines        R208
RDRTN71L EQU   *                                                   R208
         MVI   LVARNL,C' '             Clear LVARNL                R208
         MVC   LVARNL+1(255),LVARNL                                R208
         L     R3,SHVNAML              length of variable name     R208
         CL    R3,=F'255'              var name longer than 255?   R208
         BH    RDRTN71M                if longer jump              R208
         BCTR  R3,0                    prepare "EX"                R208
         MVC   LVARNL(*-*),VARNAME     move variable name          R208
         EX    R3,*-6                  execute MVC                 R208
         B     RDRTN71N                                            R208
RDRTN71M EQU   *                                                   R208
         MVC   LVARNL(254),VARNAME     move variable name          R208
         MVI   LVARNL+254,C'*'         move * to end of var name   R208
RDRTN71N EQU   *                                                   R208
         MVI   LVARNL+255,C'='         move = after var name       R208
         LA    R3,256                  R3=256                      R208
         LA    R14,LINE                "to" address                R208
         L     R15,LRECL               "to" length                 R208
         SR    R15,R3                  length - 256                R208
         MVCL  R14,R0                  move data to LINE           R208
         LA    R0,LINEAL               DATA ADDRESS incl. varname  R208
         L     R1,LRECL                DATA LENGTH                 R208
RDRTN72  EQU   *                                                   R208
         CLI   RECFM,C'F'              RECFM=F?
         BNE   RDRTN74                 no, jump
         CL    R1,LRECL                needs padding?
         BNL   RDRTN74                 no, jump
         LA    R14,LINE                "to" address
         L     R15,LRECL               "to" length
         ICM   R1,B'1000',BLANKS       padding
         MVCL  R14,R0                  move data to LINE
         LA    R0,LINE                 DATA ADDRESS
         L     R1,LRECL                DATA LENGTH
RDRTN74  EQU   *
         ST    R0,0(,R6)               PASS DATA ADDRESS
         ST    R1,0(,R7)               PASS DATA LENGTH
         ST    R5,LASTLINE             CURRENT LINE NUMBER
         L     R13,4(,R13)             BRIF SAVE AREA
         RETURN (14,12),RC=0           GOBACK TO EDIT
*---------------------------------------------------------------------*
*                                                                     *
*        Scan variables to find the highest one                       *
*                                                                     *
*        This section determines the number of the last line and      *
*        passes it to BRIF/VIIF/EDIF along with the EOF indicator.    *
*                                                                     *
*---------------------------------------------------------------------*
RDRTN79  L     R5,STEMCOUNT            eof
         B     RDRTN81
RDRTN80  BCTR  R5,0                    previous line
RDRTN81  EQU   *
         CL    R5,LASTLINE             was good?
         BE    RDRTN88                 yes, exit
         L     R5,LASTLINE             previous line
*loop
RDRTN84  LA    R5,1(,R5)               BUMP LINE NUMBER
         CL    R5,STEMCOUNT            end reached?
         BH    RDRTN87                 yes, exit with RC=8
         CLI   SHVRET,SHVLVAR          last variable to fetch?     R208
         BE    RDRTN87                 yes, exit with RC=8         R208
         BAL   R14,FETCHVAR         <- retrieve stemmed variable
*check for empty variable generally created with:  stem. = ' '
         OC    SHVVALL,SHVVALL         length=0 ?
         BZ    RDRTN87                 yes, exit
         CLI   SHVRET,SHVCLEAN         OK?
         BE    RDRTN84                 yes, try next variable
*endloop
RDRTN87  BCTR  R5,0                    previous line
         ST    R5,LASTLINE             save number of last line
*RDRTN88  ST    R5,0(,R4)               LAST LINE
*         L     R13,4(,R13)             BRIF SAVE AREA
*         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)
RDRTN88  EQU   *                                                   R208
         CLI   SERVICE,C'V'            VIIF?                       R208
         BE    RDRTN88V                YES, JUMP                   R208
         CLI   SERVICE,C'E'            EDIF?                       R208
         BE    RDRTN88V                YES, JUMP                   R208
         S     R5,CURRECNO             subtract 4th arg            R208
RDRTN88V EQU   *                                                   R208
         ST    R5,0(,R4)               # of lines to display       R208
         L     R13,4(,R13)             BRIF SAVE AREA              R208
         RETURN (14,12),RC=8           GOBACK TO BRIF (EOF)        R208
*---------------------------------------------------------------------*
*                                                                     *
*        Fetch value of a variable                                    *
*                                                                     *
*        1. build variable name by concatenating the stem name        *
*           (such as "LINE.") to the sequence number in R5            *
*        2. pass control to IRXEXCOM                                  *
*                                                                     *
*---------------------------------------------------------------------*
FETCHVAR LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)
         LTR   R3,R3                   variable name specified?
         BNP   FETCHV50                no, PULL from stack
         CLI   VAR1,C'*'               Read all variables?         R208
         BE    FETCHV40                yes jump to FETCHV40        R208
         LR    R0,R5                   seqno
         BAL   R15,BLDVARNM         <- build variable name
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)
         BR    R15                     FETCH VARIABLE
*
FETCHV40 EQU   *                                                   R208
         LA    R0,255                                              R208
         ST    R0,SHVUSER              Length of varname buffer    R208
         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME     R208
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208
         BR    R15                     FETCH VARIABLE              R208
*
*        PULL an element from the data stack
*
FETCHV50 LR    R2,R14                  save return address
         L     R15,ADDR_OF_ENVBLOCK    Environment block
         L     R15,ENVBLOCK_IRXEXTE-ENVBLOCK(,R15) A(IRXEXTE)
         L     R15,IRXSTK-IRXEXTE(,R15) STACK MANAGER
         LA    R1,IRXSTK_PARM          PARM LIST
         BALR  R14,R15              <- CALL IRXSTK
         LTR   R15,R15                 EOF yet?
         BZR   R2                      no, goback
         MVI   SHVRET,SHVNEWV          yes, simulate EOF
         BR    R2                      and goback
         DROP
HEXTAB   DC    C'0123456789ABCDEF'
***********************************************************************
*                                                                     *
*        Write Routine (SERVICE=EDIT)                                 *
*                                                                     *
***********************************************************************
WRITERTN SAVE  (14,12),,*
         LR    R12,R15
         USING WRITERTN,R12
         LR    R14,R13                 CALLER'S SAVE AREA
         L     R13,16(,R1)             PTR TO DIALOG DATA AREA
         L     R13,0(,R13)             A(SAVE2)
         LA    R13,SAVE3-SAVE2(,R13)   A(SAVE3)
         ST    R14,4(,R13)             CHAIN SAVE AREAS
         ST    R13,8(,R14)             CHAIN SAVE AREAS
         USING SAVE3,R13
         L     R6,00(,R1)              RECORD DATA
         L     R7,04(,R1)              LENGTH
         L     R4,08(,R1)              SOURCE/CHANGE BITS
         L     R5,12(,R1)              REQUEST CODE
*              REQ=0                   write next record
*              REQ=1                   first write request
*              REQ=2                   last write request
*              REQ=3                   first and last write request
*              REQ=4                   no record to write (all deleted)
*
         L     R9,LINE_LEN_ADDR+4      A(LINE)
         USING LINE_DSECT,R9
         LA    R10,DYNAM_SHVB
         USING SHVBLOCK,R10
         L     R5,0(,R5)               request code
         CH    R5,=H'0'                write next record
         BE    WRTRTN40                yes, skip DROPVAR
         CH    R5,=H'2'                write last record
         BE    WRTRTN40                yes, skip DROPVAR
         CLI   VAR1,C'*'               Fetch all vars?             R208
         BE    WRTRTN40                yes, skip DROPVAR           R208
*
*        First time only: DROP stem. variables
*
DROPVAR  LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)
         ST    R3,SHVNAML              LENGTH OF VARIABLE NAME
         MVI   SHVCODE,SHVDROPV        DROP STEM VARIABLE
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)
         BALR  R14,R15              <- DROP STEM VARIABLE
*
*        Write current record to stem.nnn
*
WRTRTN40 CH    R5,=H'4'                any record to write?
         BE    WRTRTN80                no, exit
         MVC   SHVVALA,0(R6)           Record ADDRESS
         MVC   SHVVALL,0(R7)           Record LENGTH
         LA    R0,1                    count output records
         AL    R0,WRTLINUM             count output records
         ST    R0,WRTLINUM             count output records
         CLI   VAR1,C'*'               Fetch all vars?             R208
         BE    WRTRTN90                                            R208
         BAL   R15,BLDVARNM         <- build variable name
         MVI   SHVCODE,SHVSTORE        STORE VARIABLE
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)
         BALR  R14,R15              <- STORE VARIABLE
*
*        Last record only: set stem.0 to the number of records written
*
WRTRTN80 EQU   *
         CH    R5,=H'2'                last record ?
         BL    WRTRTN99                no, exit
         CLI   VAR1,C'*'               Fetch all vars?             R208
         BE    WRTRTN99                yes, exit                   R208
         L     R0,WRTLINUM             count output records
         CVD   R0,DWD                  seqno
         OI    DWD+7,15
         UNPK  LINE(8),DWD             99999999
         LA    R0,LINE                 unpack 7 digits
         ST    R0,SHVVALA              Value addr
         LA    R0,8                    Value length
         ST    R0,SHVVALL              Value length
         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)
         LA    R0,1(,R3)               add one byte for "0"
         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME
         LA    R14,VARNAME             "to" addr
         LR    R15,R3                  "to" length
         MVCL  R14,R2                  move stem.
         MVI   0(R14),C'0'             append a "0" : stem.0
         MVI   SHVCODE,SHVSTORE        STORE VARIABLE
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)
         BALR  R14,R15              <- STORE stem.0 VARIABLE
         B     WRTRTN99                END                         R208
*                                                                  R208
WRTRTN90 EQU   *                                                   R208
         LA    R14,LINE                "to" address                R208
         L     R15,LRECL               "to" length                 R208
         L     R6,SHVVALA              get value address           R208
         L     R7,SHVVALL              get value length            R208
         MVCL  R14,R6                  move data to LINE           R208
         LA    R14,LINE                address of LINE             R208
         L     R7,SHVVALL              repair R7 after MVCL        R208
         LR    R15,R7                                              R208
         MVI   TAB,X'00'               fill up TAB with '00'x      R208
         MVC   TAB+1(L'TAB-1),TAB                                  R208
         MVI   TAB+92,X'04'            '*'                         R208
         XR    R2,R2                   R2 = 0                      R208
         BCTR  R15,0                   prepare "EX"                R208
         TRT   LINE(*-*),TAB           find '*'                    R208
         EX    R15,*-6                 execute TRT                 R208
         BZ    WRTRN90A                no '*', jump                R208
         SLR   R1,R14                  position of '*'             R208
         ST    R1,POSST                store position              R208
         B     WRTRN90B                jump                        R208
WRTRN90A LR    R1,R7                   max position                R208
         ST    R1,POSST                store position              R208
WRTRN90B MVI   TAB+92,X'00'            clear TAB                   R208
         MVI   TAB+64,X'04'            ' '                         R208
         XR    R2,R2                   R2 = 0                      R208
         TRT   LINE(*-*),TAB           find ' '                    R208
         EX    R15,*-6                 execute TRT                 R208
         BZ    WRTRN90C                no ' ', jump                R208
         SLR   R1,R14                  position of ' '             R208
         ST    R1,POSBL                store position              R208
         B     WRTRN90D                jump                        R208
WRTRN90C LR    R1,R7                   max position                R208
         ST    R1,POSBL                store position              R208
WRTRN90D MVI   TAB+64,X'00'            clear TAB                   R208
         MVI   TAB+0,X'04'             '00'x                       R208
         XR    R2,R2                   R2 = 0                      R208
         TRT   LINE(*-*),TAB           find '00'x                  R208
         EX    R15,*-6                 execute TRT                 R208
         BZ    WRTRN90E                no '00', jump               R208
         SLR   R1,R14                  position of '00'x           R208
         ST    R1,POS00                store position              R208
         B     WRTRN90F                jump                        R208
WRTRN90E LR    R1,R7                   max position                R208
         ST    R1,POS00                store position              R208
WRTRN90F MVI   TAB+0,X'00'             clear TAB                   R208
         MVI   TAB+126,X'04'           '='                         R208
         XR    R2,R2                   R2 = 0                      R208
         TRT   LINE(*-*),TAB           find '='                    R208
         EX    R15,*-6                 execute TRT                 R208
         BZ    WRTRN90G                no '=', DROP var?           R208
         SLR   R1,R14                  position of '='             R208
         ST    R1,POSEQ                store position              R208
         B     WRTRN90H                jump                        R208
WRTRN90G EQU   *                       DROP var                    R208
         CL    R7,POSST                '*' in line?                R208
         BH    WRTRTN99                yes - jump back to EDIF     R208
         LR    R2,R14                  convert to uppercase        R208
         L     R3,LRECL                convert to uppercase        R208
         OI    0(R2),X'40'             convert to uppercase        R208
         LA    R2,1(,R2)               convert to uppercase        R208
         BCT   R3,*-8                  convert to uppercase        R208
         CLC   LINE(5),=C'DROP '       DROP a variable?            R208
         BNE   WRTRTN99                no - jump back to EDIF      R208
         LA    R1,5                    R1 = 5                      R208
         LR    R2,R14                  R2 = Address of LINE        R208
         AR    R2,R1                   Start of var name           R208
         ST    R2,SHVNAMA              ADDRESS OF VARIABLE NAME    R208
         L     R2,POS00                end of variable name        R208
         SLR   R2,R1                   R2 = R2 - 5                 R208
         ST    R2,SHVNAML              LENGTH OF VARIABLE NAME     R208
         LA    R1,250                  max length of var name      R208
         CR    R2,R1                   name too long?              R208
         BH    WRTRTN99                yes, goback to EDIF         R208
         MVI   SHVCODE,SHVDROPV        DROP VARIABLE               R208
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208
         BALR  R14,R15              <- DROP VARIABLE               R208
         B     WRTRTN99                jump back to EDIF           R208
WRTRN90H EQU   *                       SET var                     R208
         CLC   POSST,POSEQ             '*' before '=' ?            R208
         BL    WRTRTN99                yes - jump back to EDIF     R208
         CLC   POSBL,POSEQ             ' ' before '=' ?            R208
         BL    WRTRN90I                yes - jump over next libes  R208
         ST    R14,SHVNAMA             ADDRESS OF VARIABLE NAME    R208
         L     R1,POSEQ                POS of '=' is var length    R208
         ST    R1,SHVNAML              set var length              R208
         B     WRTRN90J                jump over next lines        R208
WRTRN90I ST    R14,SHVNAMA             ADDRESS OF VARIABLE NAME    R208
         L     R1,POSBL                POS of ' ' is var length    R208
         ST    R1,SHVNAML              set var length              R208
WRTRN90J L     R1,POSEQ                R1 = pos of '='             R208
         L     R2,POS00                R2 = End of line            R208
         SLR   R2,R1                   R2 = R2 - R1                R208
         ST    R2,SHVVALL              set value length            R208
         LA    R1,1(,R1)               R1 = R1 + 1                 R208
         AR    R1,R14                  R1 = R1 + address of line   R208
         ST    R1,SHVVALA              Convert variable name to    R208
         L     R2,SHVNAMA              uppercase                   R208
         L     R3,SHVNAML              convert to uppercase        R208
         LA    R1,250                  max length of var name      R208
         CR    R3,R1                   name too long?              R208
         BH    WRTRTN99                yes, goback to EDIF         R208
         OI    0(R2),X'40'             convert to uppercase        R208
         LA    R2,1(,R2)               convert to uppercase        R208
         BCT   R3,*-8                  convert to uppercase        R208
         MVI   SHVCODE,SHVSTORE        STORE VARIABLE              R208
         LM    R15,R1,IRXEXCOM_REGS    A(IRXEXCOM,ENVBLK,IRXPARM)  R208
         BALR  R14,R15              <- STORE VARIABLE              R208
         B     WRTRTN99                jump back to EDIF           R208
*
WRTRTN99 L     R13,4(,R13)             EDIF SAVE AREA
         RETURN (14,12),RC=0           GOBACK TO BRIF (EOF)
         DROP  R12
***********************************************************************
*                                                                     *
*        Build Variable Name                                          *
*                                                                     *
***********************************************************************
BLDVARNM CVD   R0,DWD                  seqno
         BALR  R2,0                 <- local base
         MVC   LINE(8),=X'4020202020202020'-*(R2)
         LM    R2,R3,STEMNAME          2ND ARG (VAR NAME)
         LA    R0,VARNAME              "to" addr
         LR    R1,R3                   "to" length
         MVCL  R0,R2                   move stem name "LINE."
         EDMK  LINE(8),DWD+4           unpack 7 digits
         LR    R2,R1                   addr of 1st non-zero byte
         LA    R3,LINE+8               calc length
         SLR   R3,R2                   calc length
         LR    R1,R3                   "to" length
         MVCL  R0,R2                   move seq number
         LA    R1,VARNAME              "to" addr
         SLR   R0,R1                   calc length of variable name
         ST    R0,SHVNAML              LENGTH OF VARIABLE NAME
         BR    R15                     GOBACK
***********************************************************************
*                                                                     *
*        CONSTANTS                                                    *
*                                                                     *
***********************************************************************
$CONTROL DC    C'CONTROL '
$ERRORS  DC    C'ERRORS '
$RETURN  DC    C'RETURN '
$DISPLAY DC    C'DISPLAY '
$REFRESH DC    C'REFRESH '
$VCOPY   DC    C'VCOPY '
$VERASE  DC    C'VERASE '
$SETMSG  DC    C'SETMSG '
$VDEFINE DC    C'VDEFINE '
$ZERRMSG DC    C'ZERRMSG '
$ZENVIR  DC    C'ZENVIR '
$SAVE    DC    C'SAVE '
$RESTORE DC    C'RESTORE '
$ZCMD    DC    C'ZCMD '
$VIEW    DC    C'VIEW '
$MOVE    DC    C'MOVE '
SYNTAXMSG DC     C'Syntax: CALL STEMEDIT service<,stemname><,firstelem>X
               <,stemcount><,title><,panel><,lrecl><,recfm><,profile>'
***********************************************************************
*                                                                     *
*        Dynamic Storage Area - LOC=BELOW                             *
*                                                                     *
***********************************************************************
DYNAM    DSECT
         DS    18F                     MAIN-LINE
SAVE2    DS    18F                     Save area for cmd rtne
SAVE3    DS    18F                     Save area for read/write rtnes
*
DWD      DS    D                       work area for CVB/CVD
R15R0R1  DS    A(R15,R0,R1)            regs at entry to STEMEDIT
ISPLINKº DS    V(ISPLINK)              ISPF INTERFACE
ADDR_OF_ENVBLOCK EQU R15R0R1+4,4,C'A'  ENVIRONMENT BLOCK
PANEL_NAME DS  C'ISRBROBA'             PANEL (6th arg)
TITLE    DS    CL54                    Title
SERVICE  DS    C'BROWSE'               ISPF Service ("B" or "V" or "E")
RECFM    DS    C'V '                   record format
PROFILE_NAME DS CL8'TEXT'              profile name for EDIF/VIIF
STEMNAME DS    A,F                     ADDR/LEN OF STEM NAME (2nd arg)
CURRECNO DS    F                       first element (3rd arg)
STEMCOUNT DS   F                       number of variables (4th arg)
LRECL    DS    F                       record length (7th arg)
LASTLINE DS    F                       last line number
WRTLINUM DS    F                       line number for write rtne
LINE_LEN_ADDR DS F,A(LINE_DSECT)       length and address of LINE fld
PARMLIST DS    12F                     EDIF/BRIF/VIIF Parm List
RDCMDWR  DS    A(RDRTNE,CMDRTNE,WRITERTN) READ/CMD/WRITE Routines
IRXEXCOM_REGS DS A(R15,R0,R1)          IRXEXCOM
IRXEXCOM_PARM DS 4A                    IRXEXCOM
IRXSTK_PARM DS 6A                      IRXSTK
DYNAM_SHVB DS  XL(SHVBLEN)             SHVB (IRXEXCOM)
RETCODE  DS    F                       RETURN CODE
VALUE    DS    F                       VALUE RETURNED BY FUNCTION
VARNAME  DS    CL255                   variable name
VAR1     DS    CL1                     VARNAME first character     R208
VARL     DS    CL1                     Form of var-list S or L     R208
POSEQ    DS    F                       position of '='             R208
POSBL    DS    F                       position of ' '             R208
POS00    DS    F                       position of '00'x           R208
POSST    DS    F                       position of '*'             R208
ZENVIR   DS    CL32'ISPF 3.2'          CURRENT ISPF LEVEL
ZERRMSG  DS    CL8                     error message
WORK80   DS    CL80                    work area
BLANKS   DS    CL256                   a bunch of blanks
TAB      DS    XL256                   table for TRT               R208
DYNAML   EQU   *-DYNAM
*
LINE_DSECT DSECT                       RMODE=31
LINEAL   DS    0CL33016                Line in * output, long varn R208
LVARNL   DS    CL216                   Long varname in * output    R208
LINEA    DS    0CL32800                Line in * output            R208
LVARN    DS    CL40                    Varname in * output         R208
LINE     DS    CL32760
*
         PRINT NOGEN
         IRXEFPL DSECT=YES             External Function Parm List
         IRXENVB                       Environment Block
         IRXEXTE                       External Function Entry Points
         IRXSHVB                       Shared REXX Variable Req Block
         YREGS                         Register Equates (R0-R15)
         END
//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),BLKSIZE=3200
//*
//LKED    EXEC PGM=IEWL,PARM='LIST,MAP,RENT,REFR'
//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,DELETE)
//SYSPRINT DD SYSOUT=*
//SYSLMOD  DD DSN=GILBERT.FILE183.LOAD(STEMEDIT),DISP=SHR
./ ADD NAME=STEMEMCB 0100-13230-13230-1410-00014-00014-00000-RNOWAK
/* Rexx **************************************************************/
/* Edit Macro for STEMEDIT 'EDIT','*'                                */
/* Call this macro at the beginning of the edit session to change    */
/* all '00'x in blanks and shift the '=' to the left.                */
/* At the end of the edit session STEMEMCE should be called to end   */
/* up the lines with '00'x                                           */
/*********************************************************************/
"ISREDIT MACRO"
"ISREDIT CHANGE '00'X '40'X ALL"
DO UNTIL RC > 0
   "ISREDIT CHANGE '  =' ' =' ALL"
END
"ISREDIT MEND"
EXIT
./ ADD NAME=STEMEMCE 0100-13230-13230-1410-00022-00022-00000-RNOWAK
/* Rexx **************************************************************/
/* Edit Macro for STEMEDIT 'EDIT','*'                                */
/* Call this macro at the end of the edit session to end up the      */
/* lines with '00'x.                                                 */
/*********************************************************************/
"ISREDIT MACRO"
"ISREDIT (n) = LINENUM .ZLAST"
DO i=1 to n
  "ISREDIT (currline) =LINE "i
  if POS('00'x,currline) = 0 then do
     l = LENGTH(currline)
     c = SUBSTR(currline,l,1)
     DO WHILE c = ' '
        l = l - 1
        c = SUBSTR(currline,l,1)
     END
     currline = LEFT(currline,l) !! '00'x !! SUBSTR(currline,l+2)
     "ISREDIT LINE "i" = '"currline"'"
  end
END
"ISREDIT MEND"
EXIT
./ ADD NAME=TALLY    0100-13230-13230-1410-00100-00100-00000-RNOWAK
/*---------------------------------------------------------------REXX-*Þ
!*                                                                    *!
!* MODULE NAME = TALLY                                                *!
!*                                                                    *!
!* DESCRIPTIVE NAME = Tallies tracks on DSLIST panel.                 *!
!*                                                                    *!
!* STATUS = R103                                                      *!
!*                                                                    *!
!* FUNCTION = Display the total number of tracks used up by the       *!
!*            data sets currently displayed on the Data Set List      *!
!*            panel (ISPF 3.4).  Requires that the size information   *!
!*            for all the data sets be previously obtained from the   *!
!*            VTOC, for example with a SORT SIZE command.             *!
!*                                                                    *!
!* AUTHOR   =  Gilbert Saint-Flour <carlosºgsf-soft.com>              *!
!*             http://gsf-soft.com/Freeware/                          *!
!*                                                                    *!
!* DEPENDENCIES = TSO/E V2                                            *!
!*                ISPF V3, V4, V5 or V6                               *!
!*                                                                    *!
!* SYNTAX   =  TALLY                                                  *!
!*                                                                    *!
!*             Must be issued while on the DSLIST panel, either       *!
!*             as a line command (on any line) or as TSO %TALLY.      *!
!*                                                                    *!
!* CHANGE LOG                                                         *!
!*                                                                    *!
!*101 When DTA+016=0, get DSB addr from DTA+044                       *!
!*102 Stop using DTB in ISPF 5.9 and above                Ron.Hesketh *!
!*103 Changed for ISPF above V5.9                        Rainer Nowak *!
!*                                                                    *!
Þ*--------------------------------------------------------------------*/
ADDRESS 'ISPEXEC'
tcb    = PTR(540)               /* TCB (EXEC command)    PSATOLD  */
tcb    = PTR(tcb+132)           /* TCB (ISPTASK)         TCBOTC   */
fsa    = PTR(tcb+112)           /* first save area       TCBFSA   */
r1     = PTR(fsa+24)            /* ISPTASK's R1                   */
tld    = PTR(r1)                /* TLD address                    */
dta    = PTR(tld+076)           /* DTA address                    */
tbl    = STORAGE(D2X(dta+12),8) /* Name of temp table    DSL12345 */
"VGET ZENVIR"                   /* Retrieve ISPF Version          */
IF LEFT(Zenvir,8) < 'ISPF 5.9' THEN DO
  dtb    = PTR(dta+016)           /* DTB address                  */
  IF dtb=0 THEN
    dtb  = PTR(dta+044)           /* OPEN Table Chain             */
  IF STORAGE(D2X(dtb),3) /= 'DTB' THEN DO
    SAY 'Error: Table name could not be located (DTB)' zenvir
    EXIT 12
    END
  tbl  = STORAGE(D2X(dtb+6),8)  /* Name of temp table    DSL12345 */
  END
ELSE DO                         /* ISPF >= 5.9                    */
   start = dta + 196            /* Address of first table name    */
   finished = 'NO'
   otnr = 0
   DO UNTIL finished = 'YES'
      tbl = STORAGE(D2X(start),8) /* Name of table */
      if C2X(LEFT(tbl,1)) = '00' then do
         finished = 'YES'
      end
      else do
         if LEFT(tbl,3) = 'DSL' then do
            otnr = otnr + 1
            finished = 'YES'
         end
         start = start + 12
      end
   END
   IF otnr = 0 THEN DO
    SAY 'Error: Table name could not be located' zenvir
    EXIT 12
    END
END

'CONTROL ERRORS RETURN'
'TBTOP' tbl
  IF rc>0 THEN DO
    SAY 'TBTOP failed for table' tbl 'RC='rc
    EXIT
  END

tally=0;rows=0;processed=0;zusize=0   /* Init counters */
DO FOREVER
  'TBSKIP' tbl                        /* NEXT ROW      */
  IF rc>0 THEN LEAVE
  'TBGET' tbl                         /* SET VARIABLES */
  IF rc>0 THEN LEAVE
  rows=rows+1                         /* count rows    */
  IF zusize = '' THEN ITERATE         /* ignore migrated data sets */
  tally=tally+zusize                  /* tally file size */
  processed=processed+1               /* count processed data sets */
END
ZMSG000S = tally 'Tracks'
ZMSG000L = 'Total Data sets:' rows,
           ' Data sets processed:' processed,
           ' Total tracks:' tally
"SETMSG MSG(ISPZ000)"
EXIT

PTR: RETURN C2D(STORAGE(D2X(ARG(1)),4))
